# GoQuant Matching Engine - API Documentation

## Overview

The GoQuant Matching Engine provides a comprehensive REST API for order management and market data access, complemented by real-time WebSocket and Server-Sent Events (SSE) for live data streaming.

## Base Configuration

- **Base URL**: `http://localhost:8000`
- **Protocol**: HTTP/1.1 with WebSocket upgrade support
- **Content-Type**: `application/json` for all requests
- **Response Format**: JSON with standardized error handling

## Authentication

*Note: Current implementation does not include authentication. Production deployments should implement JWT or API key authentication.*

## Order Management API

### Submit Order

Submit a new order to the matching engine.

**Endpoint:** `POST /orders`

**Request Body:**
```json
{
    "symbol": "BTC-USD",
    "side": "buy",
    "type": "limit",
    "quantity": "1.5",
    "price": "35000",
    "client_order_id": "user-order-123"
}
```

**Request Parameters:**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `symbol` | string | Yes | Trading pair symbol (e.g., "BTC-USD") |
| `side` | enum | Yes | Order side: "buy" or "sell" |
| `type` | enum | Yes | Order type: "market", "limit", "ioc", "fok", "stop", "stop_limit", "take_profit" |
| `quantity` | decimal | Yes | Order quantity as string (e.g., "1.5") |
| `price` | decimal | Conditional | Limit price (required for limit, ioc, fok, stop_limit orders) |
| `stop_price` | decimal | Conditional | Stop trigger price (required for stop, stop_limit orders) |
| `take_profit_price` | decimal | Conditional | Take profit trigger price (required for take_profit orders) |
| `client_order_id` | string | No | Client-specified order identifier |

**Order Types:**

1. **Market**: Execute immediately at best available price
2. **Limit**: Execute at specified price or better
3. **IOC (Immediate-or-Cancel)**: Execute immediately, cancel remainder
4. **FOK (Fill-or-Kill)**: Execute completely or cancel entirely
5. **Stop**: Convert to market order when stop price is hit
6. **Stop-Limit**: Convert to limit order when stop price is hit
7. **Take-Profit**: Execute when profit target is reached

**Response:**
```json
{
    "order_id": "ord_1234567890",
    "status": "accepted",
    "filled_quantity": "1.0",
    "remaining_quantity": "0.5",
    "trades": [
        {
            "trade_id": "tr_9876543210",
            "price": "35000.00000000",
            "quantity": "1.00000000",
            "aggressor_side": "buy",
            "maker_order_id": "ord_1111111111",
            "taker_order_id": "ord_1234567890",
            "timestamp": "2025-10-28T12:15:51Z",
            "maker_fee": "-0.03500000",
            "taker_fee": "0.87500000"
        }
    ]
}
```

**Response Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `order_id` | string | System-generated unique order identifier |
| `status` | string | Order status: "accepted", "rejected" |
| `filled_quantity` | decimal | Quantity filled during initial matching |
| `remaining_quantity` | decimal | Quantity remaining on the order book |
| `trades` | array | List of trades generated by this order |

**Trade Object:**

| Field | Type | Description |
|-------|------|-------------|
| `trade_id` | string | Unique trade identifier |
| `price` | decimal | Execution price |
| `quantity` | decimal | Trade quantity |
| `aggressor_side` | enum | Side of the aggressive (incoming) order |
| `maker_order_id` | string | Order ID of the passive (maker) order |
| `taker_order_id` | string | Order ID of the aggressive (taker) order |
| `timestamp` | string | Trade execution time (ISO 8601 UTC) |
| `maker_fee` | decimal | Fee charged to maker (negative = rebate) |
| `taker_fee` | decimal | Fee charged to taker |

**HTTP Status Codes:**
- `200`: Order accepted and processed
- `400`: Invalid request parameters
- `422`: Validation error
- `500`: Internal server error

### Cancel Order

Cancel an existing order.

**Endpoint:** `DELETE /orders/{order_id}`

**Path Parameters:**
- `order_id` (string): The order ID to cancel

**Response:**
```json
{
    "order_id": "ord_1234567890",
    "status": "cancelled"
}
```

**HTTP Status Codes:**
- `200`: Order successfully cancelled
- `404`: Order not found
- `500`: Internal server error

## Market Data API

### Order Book Snapshot

Retrieve current order book state.

**Endpoint:** `GET /orderbook/{symbol}`

**Path Parameters:**
- `symbol` (string): Trading pair symbol

**Query Parameters:**
- `depth` (integer, optional): Number of price levels to return (default: 10)

**Response:**
```json
{
    "symbol": "BTC-USD",
    "bids": [
        {
            "price": "34999.00000000",
            "quantity": "2.50000000"
        },
        {
            "price": "34998.00000000",
            "quantity": "1.75000000"
        }
    ],
    "asks": [
        {
            "price": "35001.00000000",
            "quantity": "1.25000000"
        },
        {
            "price": "35002.00000000",
            "quantity": "3.00000000"
        }
    ],
    "timestamp": "2025-10-28T12:15:51Z"
}
```

### Best Bid/Offer (BBO)

Get the current best bid and offer.

**Endpoint:** `GET /bbo/{symbol}`

**Response:**
```json
{
    "symbol": "BTC-USD",
    "bid": {
        "price": "34999.00000000",
        "quantity": "2.50000000"
    },
    "ask": {
        "price": "35001.00000000",
        "quantity": "1.25000000"
    },
    "timestamp": "2025-10-28T12:15:51Z"
}
```

### Trade History

Retrieve recent trade history for a symbol.

**Endpoint:** `GET /trades/{symbol}`

**Response:**
```json
{
    "symbol": "BTC-USD",
    "trades": [
        {
            "trade_id": "tr_9876543210",
            "price": "35000.00000000",
            "quantity": "1.00000000",
            "aggressor_side": "buy",
            "maker_order_id": "ord_1111111111",
            "taker_order_id": "ord_1234567890",
            "timestamp": "2025-10-28T12:15:51Z",
            "maker_fee": "-0.03500000",
            "taker_fee": "0.87500000"
        }
    ]
}
```

### Polling Endpoint (Optimized for Frontends)

Efficient endpoint combining order book and incremental trades.

**Endpoint:** `GET /poll/{symbol}`

**Query Parameters:**
- `depth` (integer, optional): Order book depth (default: 10)
- `since` (string, optional): Return only trades after this trade_id

**Response:**
```json
{
    "orderbook": {
        "symbol": "BTC-USD",
        "bids": [...],
        "asks": [...],
        "timestamp": "2025-10-28T12:15:51Z"
    },
    "trades": [
        // Only trades since the 'since' parameter
    ],
    "latest_trade_id": "tr_9876543210"
}
```

## Real-time Data Streaming

### WebSocket Market Data

Real-time order book updates.

**Endpoint:** `ws://localhost:8000/ws/marketdata`

**Connection:**
```javascript
const ws = new WebSocket('ws://localhost:8000/ws/marketdata');

ws.onopen = () => {
    console.log('Connected to market data');
};

ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    console.log('Market data update:', data);
};
```

**Message Format:**
```json
{
    "type": "orderbook_update",
    "symbol": "BTC-USD",
    "data": {
        "bids": [...],
        "asks": [...],
        "timestamp": "2025-10-28T12:15:51Z"
    }
}
```

### WebSocket Trade Stream

Real-time trade notifications.

**Endpoint:** `ws://localhost:8000/ws/trades`

**Message Format:**
```json
{
    "type": "trade",
    "symbol": "BTC-USD",
    "data": {
        "trade_id": "tr_9876543210",
        "price": "35000.00000000",
        "quantity": "1.00000000",
        "aggressor_side": "buy",
        "timestamp": "2025-10-28T12:15:51Z"
    }
}
```

### Server-Sent Events (SSE)

Alternative to WebSocket for browsers with firewall restrictions.

**Market Data Stream:** `GET /stream/marketdata`
**Trade Stream:** `GET /stream/trades`

**Usage:**
```javascript
const source = new EventSource('/stream/trades');

source.onmessage = (event) => {
    const trade = JSON.parse(event.data);
    console.log('New trade:', trade);
};

source.onerror = (error) => {
    console.error('SSE error:', error);
};
```

## Error Handling

### Standard Error Response

```json
{
    "detail": "Error description",
    "error_code": "VALIDATION_ERROR",
    "timestamp": "2025-10-28T12:15:51Z"
}
```

### Common Error Codes

| Code | HTTP Status | Description |
|------|-------------|-------------|
| `VALIDATION_ERROR` | 422 | Request validation failed |
| `ORDER_NOT_FOUND` | 404 | Order ID does not exist |
| `INSUFFICIENT_LIQUIDITY` | 400 | FOK order cannot be filled completely |
| `INVALID_PRICE` | 400 | Price outside acceptable range |
| `INVALID_QUANTITY` | 400 | Quantity outside acceptable range |
| `SYMBOL_NOT_FOUND` | 404 | Trading symbol not supported |
| `RATE_LIMIT_EXCEEDED` | 429 | Too many requests |
| `INTERNAL_ERROR` | 500 | Server-side error |

## Rate Limiting

*Note: Current implementation does not include rate limiting. Production deployments should implement per-IP and per-user rate limits.*

**Recommended Limits:**
- Orders: 10 requests/second per IP
- Market Data: 100 requests/second per IP
- WebSocket connections: 5 concurrent per IP

## Data Types and Precision

### Decimal Precision

All financial values use Python's `Decimal` type for precision:
- **Prices**: 8 decimal places (e.g., "35000.12345678")
- **Quantities**: 8 decimal places (e.g., "1.50000000")
- **Fees**: 8 decimal places (e.g., "-0.03500000")

### Timestamp Format

All timestamps use ISO 8601 format in UTC:
- Format: `YYYY-MM-DDTHH:MM:SS.ffffffZ`
- Example: `2025-10-28T12:15:51.123456Z`

### Order ID Format

System-generated IDs use a consistent format:
- Orders: `ord_` + 10-digit number
- Trades: `tr_` + 10-digit number

## SDK Examples

### Python Client Example

```python
import httpx
import asyncio

class GoQuantClient:
    def __init__(self, base_url="http://localhost:8000"):
        self.base_url = base_url
        
    async def submit_order(self, symbol, side, order_type, quantity, price=None):
        async with httpx.AsyncClient() as client:
            order_data = {
                "symbol": symbol,
                "side": side,
                "type": order_type,
                "quantity": str(quantity)
            }
            if price:
                order_data["price"] = str(price)
                
            response = await client.post(
                f"{self.base_url}/orders",
                json=order_data
            )
            return response.json()
    
    async def get_orderbook(self, symbol, depth=10):
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"{self.base_url}/orderbook/{symbol}",
                params={"depth": depth}
            )
            return response.json()

# Usage
async def main():
    client = GoQuantClient()
    
    # Submit a limit order
    order = await client.submit_order(
        symbol="BTC-USD",
        side="buy",
        order_type="limit",
        quantity="1.0",
        price="35000"
    )
    print(f"Order submitted: {order['order_id']}")
    
    # Get market data
    book = await client.get_orderbook("BTC-USD")
    print(f"Best bid: {book['bids'][0]['price']}")

asyncio.run(main())
```

### JavaScript Client Example

```javascript
class GoQuantClient {
    constructor(baseUrl = 'http://localhost:8000') {
        this.baseUrl = baseUrl;
    }
    
    async submitOrder(symbol, side, type, quantity, price = null) {
        const orderData = {
            symbol,
            side,
            type,
            quantity: quantity.toString()
        };
        
        if (price) {
            orderData.price = price.toString();
        }
        
        const response = await fetch(`${this.baseUrl}/orders`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(orderData)
        });
        
        return response.json();
    }
    
    async getOrderbook(symbol, depth = 10) {
        const response = await fetch(
            `${this.baseUrl}/orderbook/${symbol}?depth=${depth}`
        );
        return response.json();
    }
    
    connectMarketData(onUpdate) {
        const ws = new WebSocket(`${this.baseUrl.replace('http', 'ws')}/ws/marketdata`);
        
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            onUpdate(data);
        };
        
        return ws;
    }
}

// Usage
const client = new GoQuantClient();

// Submit order
client.submitOrder('BTC-USD', 'buy', 'limit', '1.0', '35000')
    .then(order => console.log('Order:', order.order_id));

// Connect to real-time data
const ws = client.connectMarketData((data) => {
    console.log('Market update:', data);
});
```

## Testing and Development

### Development Server

Start the development server:
```bash
uvicorn app.api:create_app --factory --host 0.0.0.0 --port 8000 --reload
```

### Interactive API Documentation

- **Swagger UI**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc

### Frontend Interface

- **Trading UI**: http://localhost:8000/

### Health Check

Basic server health check:
```bash
curl http://localhost:8000/bbo/BTC-USD
```

## Production Considerations

### Security

1. **HTTPS**: Use TLS for all production deployments
2. **Authentication**: Implement JWT or API key authentication
3. **Authorization**: Role-based access control for different API endpoints
4. **Rate Limiting**: Implement request throttling
5. **Input Validation**: Additional validation beyond Pydantic schemas

### Monitoring

1. **Metrics**: Instrument API endpoints with Prometheus metrics
2. **Logging**: Structured logging for all API requests
3. **Alerting**: Monitor for error rates and performance degradation
4. **Distributed Tracing**: Implement request tracing for debugging

### Performance

1. **Connection Pooling**: Use connection pools for database access
2. **Caching**: Implement Redis for frequently accessed market data
3. **CDN**: Use CDN for static market data distribution
4. **Load Balancing**: Distribute load across multiple instances

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | 2025-10-28 | Initial API implementation |

## Support

For API support and questions:
- Documentation: This file and `/docs` endpoint
- Code Examples: See `demo/` directory
- Testing: Use `/docs` interactive interface